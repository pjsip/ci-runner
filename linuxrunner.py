import datetime
import glob
import os
import shutil
import subprocess
import sys
import time
from typing import List

from runner import Runner, main

# gdb -return-child-result -batch -ex "run" -ex "thread apply all bt" -ex "quit" --args ./${file}

class LinuxRunner(Runner):
    """
    Linux runner
    """

    def __init__(self, path: str, args: List[str], 
                 timeout: int = Runner.TIMEOUT):
        super().__init__(path, args, timeout=timeout)

        self.gdb_path = shutil.which('gdb')
        if not self.gdb_path:
            raise Exception('Could not find gdb')

    @classmethod
    def get_dump_dir(cls) -> str:
        return os.path.abspath( os.getcwd() )

    @classmethod
    def install(cls):
        # This is equal to "ulimit -c unlimited"
        import resource
        resource.setrlimit(resource.RLIMIT_CORE,
                           (resource.RLIM_INFINITY, resource.RLIM_INFINITY))

        # Set core pattern
        os.system('echo core > /proc/sys/kernel/core_pattern')

        # Now print status
        cls.info('Installation status:')
        os.system('echo "ulimit -c    : `ulimit -c`"')
        os.system('echo "core_pattern : `cat /proc/sys/kernel/core_pattern`"')

        errors = []
        gdb_path = shutil.which('gdb')
        if not gdb_path:
            errors.append('Could not find gdb')

        if errors:
            cls.err('ERROR: ' + ' '.join(errors))
            sys.exit(1)

    def get_dump_path(self) -> str:
        dump_dir = self.get_dump_dir()
        basename = os.path.basename(self.path)
        dump_file = f'{basename}.{self.popen.pid}.dmp'
        return os.path.join(dump_dir, dump_file)
        
    def detect_crash(self) -> bool:
        """
        Determine whether process has crashed or just exited normally.
        Returns True if it had crashed.
        """
        dump_path = self.get_dump_path()
        return os.path.exists(dump_path)

    def terminate(self):
        """
        Terminate a process and generate dump file
        """
        
        # procdump default dump filename is PROCESSNAME_YYMMDD_HHMMDD.
        # Since guessing the datetime can be unreliable, let's create
        # a temporary directory for procdump to store the dumpfile.
        dtime = datetime.datetime.now()
        temp_dir = os.path.join( self.get_dump_dir(), f'ci-runner-{dtime.strftime("%y%m%d-%H%M%S")}')
        os.makedirs(temp_dir)

        # Run procdump to dump the process
        procdump_p = subprocess.Popen([
                    self.procdump_exe,
                    '-accepteula', '-o', 
                    f'{self.popen.pid}',
                ],
                cwd=temp_dir,
                )
        procdump_p.wait()
        
        # We can now terminate the process
        time.sleep(1)
        self.popen.terminate()
        
        # Get the dump file
        files = glob.glob( os.path.join(temp_dir, "*.dmp") )
        if not files:
            self.err("ERROR: unable to find dump file(s) generated by procdump")
            raise Exception('procdump dump file not found')

        # Copy and rename the procdump's dump file to standard dump file location/name
        dump_file = files[-1]
        shutil.copyfile(dump_file, self.get_dump_path())

        # Don't need the temp dir anymore
        shutil.rmtree(temp_dir)

        # Now it should be detected as crash
        if not self.detect_crash():
            dump_dir = self.get_dump_dir()
            self.err("ERROR: procdump's dump file not detected")
            self.err(f'Contents of {dump_dir}:')
            files = os.listdir(dump_dir)
            self.err('  '.join(files[:20]))


    def process_crash(self):
        """
        Process dump file.
        """
        dump_path = self.get_dump_path()
        if not os.path.exists(dump_path):
            dump_dir = self.get_dump_dir()
            self.err(f'ERROR: unable to find {dump_path}')
            self.err(f'Contents of {dump_dir}:')
            files = os.listdir(dump_dir)
            self.err('  '.join(files[:20]))
            raise Exception('Dump file not found')
        
        # Execute cdb to print crash info, but print it to stderr instead
        args = [
            self.cdb_exe,
            '-z',
            dump_path,
            '-c',
            '!analyze -v; ~* k; q',
        ]
        cdb = subprocess.Popen(args)  # , stdout=sys.stderr
        cdb.wait()



if __name__ == '__main__':
    main(LinuxRunner)
